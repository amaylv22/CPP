<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Argumentos por dirección</title>
		<link rel="shortcut icon" type="image/x-icon" href="../../../../../KonoMngr/style/icons/konoicn.png">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="../../../../../KonoMngr/style/konoguides.css" />
		<script src="../../../../../KonoMngr/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
  				TeX: { equationNumbers: { autoNumber: "AMS" } }
			});</script>
		<link rel="stylesheet" href="../../../../../KonoMngr/highlight/styles/googlecode.css">
		<script src="../../../../../KonoMngr/highlight/highlight.pack.js" type="text/javascript"></script>
		<script>hljs.initHighlightingOnLoad();</script>		
	</head>
	
	<body class="kg-content">
		<header>
			<h1>Argumentos por dirección</h1>
		</header>
		
		<article class="subsection">
			<p>Esto significa que se pasará a la función la dirección del alojamiento en memoria en que se encuentra dicha variable. Dado que el argumento de la función será una dirección, la variable debe de ser un puntero.</p>
			<pre><code>(TIPO) [FUNC_NAME] ((TIPOARG)*[NOM_ARG]...)</pre></code>
			<p>Al llamarlo en el código hay que pasar la dirección de las variables.</p>
			<pre><code>[FUNC_NAME] (&[NAME_VAR_A_PASAR] ...)</pre></code>

			<p>La diferencia está en pasar por dirección o por referencia siendo en la funcionalidad o flexibilidad de los punteros pues estos se pueden redireccionar en la implementación incluso cuando el código para referencia es más limpio.</p>
			<p>El puntero puede tomar nuevas direcciones que no (...) antes a la variable original.</p>
		</article>
		
		<article class="subsection">
			<h1 id="">Cambios de dirección de un argumento desde la función</h1>
			<p>Si lo que deseamos hacer es cambiar la dirección de alojamiento, lo que se debe de hacer es pasar la referencia por punteros, con esto se le dice al compilador que cualquier cambio en la variable (a referencia) debe ser hecha a la variable original.</p>
			<pre><code>*&[NAME_VAR]</pre></code>
			<p>Hecho del modo correcto entonces puede crearse una referencia al (...) y el (...) cambia.</p>
			<pre><code>[NAME_VAR] = &[NEW_DIR]</pre></code>
			<p>La forma de implementar es igual a la de argumentar punteros.</p>
		</article>

		<article class="subsection">
			<h1 id="">Funciones que devuelven dirección (Punteros)</h1>
			<p>En ocaciones se desea regresar dirección como salida de una función, frecuentemente se usa para la asignación de dirección de memoria, es decir, regresar un nuevo alojamiento de memoria.</p>
			<table border="0" cellspacing="5" cellpadding="10px" style="text-align: left; margin-left: auto; margin-right: auto;">
				<caption></caption>
				<thead>
					<tr>
						<th></th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><pre><code>int * Allocate Array(INT SIZE)
{RETURN NEW INT[SIZE];}</pre></code></td>
						<td><pre><code>INT MAIN ()
{
INT *pnARRAY = ALLOCATE ARRAY(25);
.
.
.
DELETE [] pnARRAY;
}</pre></code></td>
					</tr>
				</tbody>
			</table>
		</article>

		<article class="subsection">
			<h1 id="">Namespaces</h1>
			<p>Los namespaces determinan el ámbito o la porción de código en que se garantiza que un comando o llamada a función es única. Esta ayuda a evitar naming collision, que se presenta cuando el compilador quiere llamar a una función y evita núcleos con el mismo nombre, así no sabe a quién llamar.</p>
			<p>Hay dos maneras de evitar el naming collision, la primera es usando el <b>operador de acceso (: :)</b>. Si tenemos librerías con menos nombres de funciones podemos usar este operador para identificar la llamada. (...) en una función FUNCION( ) definido en la librería VARIOS.h, también evita una función diferente pero con el mismo nombre y se encuentra en la librería OTROS.h, así para llamar a cada función utilizaremos:</p>
			<pre><code>VARIOS::FUNCION(); ó OTROS::FUNCION();</pre></code>
			<p>La segunda opción es usar la Key(...) namespace para definir el código que pertenece a cada librería. El efecto del namespace aplicado (...) hasta que se aplique (...) (...), lo que se hace es decirle al compilador que si no (...) en el puntero namespace define la busqueda en el (...).</p>
			<pre><code>namespace VARIOS;
	FUNCION();

o

NAMESPACE OTROS;
	FUNCION ();</pre></code>
			<p>Generalemente se declara un namespace (.............)</p>
			<pre><code>USING NAMESPACE std;</pre></code>
	</body>
</html>	
