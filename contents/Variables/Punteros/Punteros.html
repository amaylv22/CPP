<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Punteros</title>
		<link rel="shortcut icon" type="image/x-icon" href="../../../../../KonoMngr/style/icons/konoicn.png">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="../../../../../KonoMngr/style/konoguides.css" />
		<script src="../../../../../KonoMngr/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
  				TeX: { equationNumbers: { autoNumber: "AMS" } }
			});</script>
		<link rel="stylesheet" href="../../../../../KonoMngr/highlight/styles/googlecode.css">
		<script src="../../../../../KonoMngr/highlight/highlight.pack.js" type="text/javascript"></script>
		<script>hljs.initHighlightingOnLoad();</script>		
	</head>
	
	<body class="kg-content">
		<header>
			<h1>Punteros</h1>
		</header>
		
		<article class="subsection">
			<p>Los punteros representan la mayor diferencia entre C++ y C en comparación con los otros lenguajes, lo que es característico entre lo que otorga a C y C++ es <b>su potencia</b>.</p>
			<p>Para entender la forma en la que trabajan los punteros o apuntadores es necesario entender cómo se almacenan los datos en la compuadora. La memoria está compuesta por <b>unidades básicas (bits)</b>. Cada bit solo puede tomar dos valores mutuamente excluyentes 0 y 1 (bajo y alto). Pero trabajar con bits no es práctico y por eso se agrupan en <b>conjuntos de 8 bits</b>, cada conjunto es llamado <b>byte</b>. El programador solo puede manejar directamente a grupos de 2 a 4 bytes.</p>
			<p>Cada byte dentro de la memoria tiene una dirección (localización), asignada por medio de la cuál se puede acceder a la información que este contine o a disponer del espacio de memoria (...). Esta dirección es llamada normalmente <b>dirección de memoria</b>.</p>
			<p>Así, un <b>puntero</b> es un <b>tipo especial de variable que contiene una dirección de una variable</b> que apunta hacia cierto campo dentro de la unidad de almacenamiento. A partir de esa dirección puede haber o se puede referir dicha dirección a <b>cualquier tipo de objeto</b>, un char, int, float, double, un array, una etructura, una función u otro puntero.</p>
			<pre><code>* → operadores de dirección → "puntero a"</pre></code>
			<article class="note"><p>Los punteros siempre apuntan hacia un objeto de tipo determindo.</p></article>

			<h2>Declarar un puntero.</h2>
			<pre><code>(TIPO)_*_(IDENTIFICADOR); → Tipo de variable que guarda el puntero.
(TIPO)_*_(IDENTIFICADOR) = 0 → Inicializar puntero.</pre></code>

			<article class="note"><p>Todos los punteros al ser creados deben ser inicializados, si no se sabe a dónde, se hace nula, es decir = 0. Si no se crea un puntero (...).</p>
			<p>Por ejemplo. <b>Inicializar</b></p>
			<pre><code>INT * ENTERO;
INT * ENTERO;</pre></code>
			<p>Debe quedar claro que <b>ENTERO</b> es una <b>variable de tipo "puntero a int"</b> y una variable de tipo <b>"int"</b>.</p></article>

			<p>Si "ENTERO" apunta a una variable de tipo "int", es decir, contiene la dirección de una localización, "*ENTERO" será el contenido de esa variable, no se debe olvidar que "*ENTERO" es un operador aplicado a una variable de tipo "puntero a int", es decir, <b>"*ENTERO" es una expresión</b> no una variable.</p>
			<p>Para averiguar la dirección de memoria de cualquier variable se usa el operador de dirección (&) "dirección de". LOs tipos deben de ser compatibles, para almacenar la dirección de un determinado tipo de variable, necesitan un puntero de dicho tipo.</p>
			<p>Por ejemplo. <b>Asignar dirección de variable a punto</b></p>
			<pre><code>INT A;
INT *PUNTO;
PUNTO = &A // PUNTO apunta hacia la variable A.
*PUNTO = 18 // Equivale a la línea A=18</pre></code>
			<article class="note"><p>& → Address of.</p></article>

			<h1>Operaciones con punteros.</h1>
			<ul>
				<li><p>a) Asignar a un puntero la dirección de una variable y su valor respectivamente. Por ejemplo.</p>
				<pre><code>INT A = #;
INT *P;
	P = &A
	*P = A</pre></code></li>
				<li><p>b) Asignar un puntero a otros (dos punteros apuntando a la misma dirección). Por ejemplo.</p>
				<pre><code>INT *g, *P;
INT a;
	g = &a
	P = g</pre></code></li>

			<h2 id="">Operaciones aritméticas.</h2>
			<dl>
				<dt>(PUNT_IDENTIFICADOR)++;</dt>
					<dd><p>Incrementa en 1*SIZEOF((TIPO)) la dirección de memoria almacenada en el puntero.</p></dd>
				<dt>(PUNT_IDENTIFICADOR) = (PUNT_IDENTIFICADOR) + (NUMERO_VAL);</dt>
					<dd><p>Incrementa en (NUMERO_VAL)*SIZEOF((TIPO)) la dirección de memoria almacenada en el puntero.</p></dd>
				<dt>(PUNT_IDENTIFICADOR) += (NUMERO_VAL);</dt>
			</dl>
		</article>

		<article class="subsection">
			<ul>
				<li><p>Sustracción de punteros.</p>
				<pre><code>INT *g, *P;

COUT ((g-P((ENDL;</pre></code>La (...) entre las posiciones de punteros de (...).</p></li>
				<li><p>La suma de punteros no está permitida por el computador.</p></li>
		</article>

		<article class="subsection">
			<h1>Comparación entre punteros.</h1>
			<p>Los operadores de comparación de punteros pueden tener utilidad por ejemplo cuando queremos averiguar si estamos usando un puntero, o si está en su condición de inicio (en el caso de que se haya inicializado NULL después de su declaración). Para este fin es posible adoptar muy variadas sintaxis. (INT *P;)<p>
			<pre><code>IF (NULL !=P)
IF (P)
IF (NULL == P)
IF (!P)</pre></code>
		
			<h1>Punteros genéricos.</h1>
			<p>Es posible declarar punteros sin tipo concreto. Estos pueden apuntar a objetos de cualquier tipo.</p>
			<pre><code>VOID *(IDENTIFICADOR);</pre></code>
			<p>Y para indicar que tipo de valor se quiere ingresar a él se utiliza:</p>
			<pre><code>(IDENTIFICADOR) = ((TIPO) *) (VAR_CON_INFO)</pre></code>
			<p>Para mostrar dicha información en algún tipo determinado (puede ser distinto al de ingreso) se usa:</p>
			<pre><code>COUT ((*((TIPO)*) (IDENTIFICADOR)</pre></code>

			<h1>Punteros a estructuras.</h1>
			<p>Los punteros pueden también apuntar a estructuras. En este caso para referirse a cada dentro de la estructura se cambia el operador <b>"." por "→".</b></p>

			<h1>Array de Punteros.</h1>
			<pre><code>INT *NUM [ ] = { };</pre></code>

			<h1>Variables dinámicas. Asignar memoria en el Free Store.</h1>
			<p>Utilizan la memoria que no utilizan los programas, <b>"memoria heap"</b>. Es decir, los punteros direccionan la información a estas direcciones de memoria.</p>
			<p>C++ dispone de dos operadores para acceder a la memoria dinámica, son <b>"NEW"</b> y <b>"DELETE"</b>. Cuando se usa memoria dinámica, toda la memoria que se reserve durante el programa se debe de liberar antes de salir de este.</p>

			<h2 id="">NEW</h2>
			<pre><code>(PUNT_VAR_NAME) = NEW (TIPO);
*(POINT_VAR_NAME) = #;
DELETE (POINT_VAR_NAME);</pre></code>
			<p>Esto se usa para asegurar si no se inicializa o si se aplica delete y si se quiere asignar de nuevo a un espacio de memoria heap.</p>
			<p>Sin embargo es necesario primero crear el puntero, una vez a este se le asigna un espacio reservado por una variable de tipo (TIPO) en la Free Store mediante la (...) de un NEW.</p>
			<pre><code>(TIPO) * (PUNTERO_NAME) = NEW (TIPO);</pre></code>
			<p>Donde:</p>
			<p>(TIPO) * (PUNTERO_NAME) → Creación del puntero.</p>
			<p>NEW (TIPO); → Asigna el valor de retorno de NEW, cuando se le asigna un valor a *(PUNTERO_NAME) el valor será guardado en el almacen libre al que apunta este, creado por NEW.</p>
			<article class="note"><p>Estamos trabajando en FREE STORE, con las ventajas que ello conlleva.</p>
			<p>La memoria ocupada por NEW no se devuelve automaticamente al almacen, hay que crearla de manera manual.</p></article>
			<h2 id="">DELETE</h2>
			<p>Palabra clave que se le aplica al puntero una vez que se toma de uno para devolver la memoria al ordenador, es decir, limpiar o usar el contenido y devolver la memoria al heap.</p>
			<pre><code>DELETE (PUNTERO_NAME);</pre></code>
			<p>Si el puntero sale del almacen sin exlicar el delete se produce una fuga de memoria, es decir, un área de memoria no disponible. Se liberará entonces hasta que el programa finalice.</p>
			<p>Al liberar un puntero se combierte en un puntero (...), por la que (...) se debe generar el puntero nulo, de no hacer esto, si se vuelve a aplicar DELETE daría un error. En cambio si este sale hacia (.......)<p>
			<pre><code>(PUNTERO_NAME) = 0;</pre></code>

			<h2 id="">Acceder datos miembro de una clase (objeto de una clase).</h2>
			<pre><code>(*(PUNTERO_NAME)).(DATO MIEMBRO);</pre></code>
			<p>(*(PUNTERO_NAME)) → Da prioridad.</p>
			<p>Este es el caso de que se halle creado un objeto en la memoria heap. Por ejemplo:</p>
			<pre><code>(CLASE_NOM)*(PUNT_NAME = NEW (CLASE_NOM))</pre></code>
			<p>Sin embargo, es posible acceder a los datos miembro mediante un atajo, el <b>Operador de acceso a miembro de una clase (->)</b>, así el acceso es igual a:</p>
			<pre><code>(PUNTERO_NAME) -> (DATO MIEMBRO);</pre></code>

			<h2 id="">Inicializar datos en la memoria heap</h2>
			<pre><code>(PUNTERO_NAME) = NEW (TIPO) ((VAL_INICIO))</pre></code>
			<p>Por ejemplo:</p>
			<pre><code>INT * pEDAD = NEW INT (2); │=│ INT * pEDAD;
							   pEDAD = NEW INT (2);</pre></code>
			<h1>Puntero this.</h1>
			<p>Es un <b>puntero oculto</b> que el computador crea automáticamente cada que creamos una función miembro de una clase. Este puntero <b>apunta a "este"</b>, es decir, al propio objeto que lo crea.</p>
			<p>Ya que "this" apunta al propio objeto, se tendrá una clase con un dato miembro llamado <b>HOLA</b> y un (.......)</p>
			<pre><code>(CLASE) :: SALUDO ()						(CLASE) :: SALUDO() {
{RETURNthis -> HOLA;			│=│			RETURNHOLA;}
}

(CLASE) :: SALUDO()
{RETURN (*this), HOLA;}</pre></code>

			<h1>Palabra clave CONST con puntero</h1>
			<pre><code>CONST(TIPO) * (PUNT_NAME);</pre></code>
			<article class="note"><p>CONST(TIPO) → Puntero a una constante tipo (TIPO). Los valores se pueden cambiar con datos reales o miembros</p>
			<p>(PUNT_NAME) → El valor que está guardando no puede ser cambiado. Se puede cambiar la dirección.</p></article>

			<pre><code>(TIPO) * CONST(PUNT_NAME);</pre></code>
			<article class="note"><p>(TIPO)*CONST → El valor tipo (TIPO) puede ser cambiado.</p>
			<p>(PUNT_NAME) → El puntero no puede apuntar a ningún otra dirección.</p></article>

			<pre><code>CONST(TIPO) * CONST(PUNT_NAME);</pre></code>
			<article class="note"><p>CONST(TIPO) → Valor al que apunta no puede ser cambiado.</p>
			<p>CONST(PUNT_NAME) → El puntero no puede ser cambiado pero apunta hacia cualquier otro lado.</p></article>

			<p>Los punteros const se pueden utilizar por ejemplo para aumentar la eficacia del código (angosta por referencia), pero sin perder la seguridad que proporciona el peso por vaor. Ya que un punto Const solo nos permite acceder a los miembros accesorios de una clase declarados explícitamente como constantes.</p>
			<p>Por ejemplo:</p>
			<pre><code>CONST(NOM_CLASE) * CONST(FUNC_NAME) (CONST(NOM_CLASE) * CONST(Obj_NAME))</pre></code>
		</article>
		
	</body>
</html>	
